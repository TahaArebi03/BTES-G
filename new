#include <iostream>
#include <vector>
#include <string>
#include <stdexcept>
#include <map>
#include <fstream>
#include <cassert>

using namespace std;

// Class to represent a person (Admin or User)
class Person {
protected:
    string Username; // User's username
    string Password; // User's password

public:
    // Constructor
    Person(string user, string pass) : Username(user), Password(pass) {}

    virtual bool Login() = 0; // Pure virtual function for login

    string GetUsername() const { return Username; }
    string GetPassword() const { return Password; }
};

// Admin class inheriting from Person
class Admin : public Person {
public:
    // Constructor
    Admin(string user, string pass) : Person(user, pass) {}

    bool Login() override {
        string EnteredUsername, EnteredPassword;
        cout << "Enter admin username: ";
        cin >> EnteredUsername;
        cout << "Enter admin password: ";
        cin >> EnteredPassword;

        return (EnteredUsername == Username && EnteredPassword == Password);
    }

    void AdminMenu();
};

// User class inheriting from Person
class User : public Person {
    int UserID; // Unique identifier for the user

public:
    // Constructor
    User(string user, string pass, int id) : Person(user, pass), UserID(id) {}

    int GetUserID() const { return UserID; }

    bool Login() override {
        string EnteredUsername, EnteredPassword;
        cout << "Enter username: ";
        cin >> EnteredUsername;
        cout << "Enter password: ";
        cin >> EnteredPassword;

        return (EnteredUsername == Username && EnteredPassword == Password);
    }

    void UserMenu(); // User menu function
    static User CreateUser(int id); // Static function to create a user
};

// Event Management Classes
class Seat {
    int SeatNumber; // Seat number
    bool IsReserved; // Indicates if the seat is reserved

public:
    // Constructor
    Seat(int number) : SeatNumber(number), IsReserved(false) {}

    int GetSeatNumber() const { return SeatNumber; }
    bool CheckAvailability() const { return !IsReserved; }
    
    void Reserve() {
        if (IsReserved) throw runtime_error("Seat already reserved.");
        IsReserved = true;
    }
};

class Event {
    int EventID; // Unique event identifier
    string Name; // Event name
    string Type; // Event type
    string Date; // Event date
    string Location; // Event location
    vector<Seat> Seats; // List of seats for the event
    static vector<Event> Events; // Static list of events
    static int NextEventID; // Static counter for unique event IDs

public:
    // Constructor
    Event(const string& eventName, const string& eventType, const string& eventDate, const string& eventLocation, int seatCount);
    
    static void AddEvent(const string& eventName, const string& eventType, const string& eventDate, const string& eventLocation, int seatCount);
    static void DeleteEvent(int eventID);
    static void ViewEvents();
    static const vector<Event>& GetEvents();
    static Event* FindEventByID(int eventID);
    
    int GetEventID() const { return EventID; }
    string GetName() const;
    string GetLocation() const { return Location; }
    int GetAvailableSeats() const;
    void ReserveSeat(int seatNumber);
    void DisplaySeats() const;
    static void SaveToFile(const string& filename);
};

// Initialize static members
vector<Event> Event::Events;
int Event::NextEventID = 1;

// Constructor implementation
Event::Event(const string& eventName, const string& eventType, const string& eventDate, const string& eventLocation, int seatCount)
    : EventID(NextEventID++), Name(eventName), Type(eventType), Date(eventDate), Location(eventLocation) {
    assert(seatCount > 0); // Ensure seatCount is positive
    for (int i = 1; i <= seatCount; ++i) {
        Seats.push_back(Seat(i));
    }
}

// Add a new event to the list
void Event::AddEvent(const string& eventName, const string& eventType, const string& eventDate, const string& eventLocation, int seatCount) {
    try {
        assert(!eventName.empty() && seatCount > 0); // Validate event name and seat count
        Events.push_back(Event(eventName, eventType, eventDate, eventLocation, seatCount));
        cout << "Event added successfully.\n";
        SaveToFile("events.txt");
    } catch (const exception& e) {
        cout << "Error adding event: " << e.what() << endl;
    }
}

// Delete an event from the list
void Event::DeleteEvent(int eventID) {
    try {
        for (auto it = Events.begin(); it != Events.end(); ++it) {
            if (it->GetEventID() == eventID) {
                Events.erase(it);
                cout << "Event deleted successfully.\n";
                SaveToFile("events.txt");
                return;
            }
        }
        throw out_of_range("Event ID does not exist.");
    } catch (const exception& e) {
        cout << "Error deleting event: " << e.what() << endl;
    }
}

// View all events
void Event::ViewEvents() {
    cout << "--- Current Events ---\n";
    for (const Event& event : Events) {
        cout << "ID: " << event.GetEventID() << ", Name: " << event.GetName()
             << " - Type: " << event.Type << ", Date: " << event.Date
             << ", Location: " << event.Location
             << " - Available Seats: " << event.GetAvailableSeats() << endl;
    }
}

// Get list of events
const vector<Event>& Event::GetEvents() {
    return Events;
}

// Find event by ID
Event* Event::FindEventByID(int eventID) {
    for (Event& event : Events) {
        if (event.GetEventID() == eventID) return &event;
    }
    return nullptr;
}

// Get event name
string Event::GetName() const {
    return Name;
}

// Get available seats
int Event::GetAvailableSeats() const {
    int availableSeats = 0;
    for (const Seat& seat : Seats) {
        if (seat.CheckAvailability()) ++availableSeats;
    }
    return availableSeats;
}

// Reserve a seat
void Event::ReserveSeat(int seatNumber) {
    try {
        assert(seatNumber > 0 && seatNumber <= Seats.size()); // Validate seat number
        Seats[seatNumber - 1].Reserve();
    } catch (const exception& e) {
        cout << "Error reserving seat: " << e.what() << endl;
    }
}

// Display seats for the event
void Event::DisplaySeats() const {
    cout << "Seats for event '" << Name << "':\n";
    for (const Seat& seat : Seats) {
        cout << "Seat " << seat.GetSeatNumber() << " - " << (seat.CheckAvailability() ? "Available" : "Reserved") << endl;
    }
}

// Save events to a file
void Event::SaveToFile(const string& filename) {
    try {
        ofstream outFile(filename);
        if (!outFile) {
            throw runtime_error("Unable to open file for writing.");
        }
        for (const Event& event : Events) {
            outFile << event.GetEventID() << " " << event.GetName() << " " << event.Type << " " << event.Date << " "
                    << event.GetLocation() << " " << event.GetAvailableSeats() << endl;
        }
        outFile.close();
    } catch (const exception& e) {
        cout << "Error saving to file: " << e.what() << endl;
    }
}

// Booking Management
class Booking {
private:
    int UserID; // User ID who made the booking
    int EventID; // Event ID for the booking
    vector<int> ReservedSeats; // List of reserved seats

public:
    // Constructor
    Booking(int userID, int eventID, const vector<int>& seats)
        : UserID(userID), EventID(eventID), ReservedSeats(seats) {}

    int GetUserID() const { return UserID; }
    int GetEventID() const { return EventID; }
    const vector<int>& GetReservedSeats() const { return ReservedSeats; }

    void CancelBooking();
    void ModifyBooking(const vector<int>& newSeats);
    static void ViewBookings(int userID);
};

// Map to store user bookings
map<int, vector<Booking>> UserBookings;

// Cancel a booking
void Booking::CancelBooking() {
    try {
        auto& bookings = UserBookings[UserID];
        for (auto it = bookings.begin(); it != bookings.end(); ++it) {
            if (it->GetEventID() == EventID) {
                bookings.erase(it);
                cout << "Booking cancelled successfully for event ID: " << EventID << endl;
                return;
            }
        }
        throw runtime_error("No booking found to cancel.");
    } catch (const exception& e) {
        cout << "Error cancelling booking: " << e.what() << endl;
    }
}

// Modify a booking
void Booking::ModifyBooking(const vector<int>& newSeats) {
    try {
        assert(!newSeats.empty()); // Ensure newSeats is not empty
        auto& bookings = UserBookings[UserID];
        for (Booking& booking : bookings) {
            if (booking.GetEventID() == EventID) {
                booking.ReservedSeats = newSeats;  // Modify seats
                cout << "Booking modified successfully for event ID: " << EventID << endl;
                return;
            }
        }
        throw runtime_error("No booking found to modify.");
    } catch (const exception& e) {
        cout << "Error modifying booking: " << e.what() << endl;
    }
}

// View bookings for a user
void Booking::ViewBookings(int userID) {
    try {
        const auto& bookings = UserBookings[userID];
        if (bookings.empty()) {
            cout << "No bookings found.\n";
            return;
        }
        cout << "--- My Bookings ---\n";
        for (const Booking& booking : bookings) {
            Event* event = Event::FindEventByID(booking.GetEventID());
            if (event) {
                cout << "Event Name: " << event->GetName() << ", Location: " << event->GetLocation()
                     << ", Reserved Seats: ";
                for (int seat : booking.GetReservedSeats()) {
                    cout << seat << " ";
                }
                cout << endl;
            }
        }
    } catch (const exception& e) {
        cout << "Error viewing bookings: " << e.what() << endl;
    }
}

// Admin Menu function
void Admin::AdminMenu() {
    int choice;
    while (true) {
        cout << "\n--- Admin Menu ---\n";
        cout << "1. Add Event\n";
        cout << "2. Delete Event\n";
        cout << "3. View Events\n";
        cout << "0. Return to Main Menu\n";
        cout << "Select an option: ";
        cin >> choice;

        switch (choice) {
            case 1: {
                string eventName, eventType, eventDate, eventLocation;
                int seatCount;
                cout << "Enter event name: ";
                cin >> eventName;
                cout << "Enter event type: ";
                cin >> eventType;
                cout << "Enter event date (YYYY-MM-DD): ";
                cin >> eventDate;
                cout << "Enter event location: ";
                cin >> eventLocation;
                cout << "Enter seat count: ";
                cin >> seatCount;
                Event::AddEvent(eventName, eventType, eventDate, eventLocation, seatCount);
                break;
            }
            case 2: {
                int eventID;
                cout << "Enter event ID to delete: ";
                cin >> eventID;
                Event::DeleteEvent(eventID);
                break;
            }
            case 3:
                Event::ViewEvents();
                break;
            case 0:
                return;
            default:
                cout << "Invalid choice.\n";
        }
    }
}

// User Menu function
void User::UserMenu() {
    int choice;
    while (true) {
        cout << "\n--- User Menu ---\n";
        cout << "1. Choose Event\n";
        cout << "2. View Available Seats\n";
        cout << "3. Book Seats\n";
        cout << "4. View My Reservations\n";
        cout << "5. Modify My Booking\n";
        cout << "6. Cancel My Booking\n";
        cout << "0. Return to Main Menu\n";
        cout << "Select an option: ";
        cin >> choice;

        switch (choice) {
            case 1: {
                Event::ViewEvents();
                int eventID;
                cout << "Enter event ID to choose: ";
                cin >> eventID;
                Event* event = Event::FindEventByID(eventID);
                if (event) {
                    cout << "Event '" << event->GetName() << "' selected successfully.\n";
                } else {
                    cout << "Invalid event ID.\n";
                }
                break;
            }
            case 2: {
                int eventID;
                cout << "Enter event ID to view seats: ";
                cin >> eventID;
                Event* event = Event::FindEventByID(eventID);
                if (event) {
                    event->DisplaySeats();
                } else {
                    cout << "Invalid event ID.\n";
                }
                break;
            }
            case 3: {
                int eventID;
                cout << "Enter event ID to book seats: ";
                cin >> eventID;
                Event* event = Event::FindEventByID(eventID);
                if (!event) {
                    cout << "Invalid event ID.\n";
                    break;
                }
                vector<int> seatNumbers;
                int numSeats;
                cout << "Enter number of seats to book: ";
                cin >> numSeats;
                assert(numSeats > 0); // Ensure a positive number of seats
                for (int i = 0; i < numSeats; ++i) {
                    int seatNumber;
                    cout << "Enter seat number to book: ";
                    cin >> seatNumber;
                    try {
                        event->ReserveSeat(seatNumber);
                        seatNumbers.push_back(seatNumber);
                    } catch (const runtime_error& e) {
                        cout << e.what() << endl; // Handle seat reservation error
                    }
                }
                UserBookings[GetUserID()].emplace_back(Booking(GetUserID(), eventID, seatNumbers));
                cout << numSeats << " seats successfully booked.\n";
                break;
            }
            case 4:
                Booking::ViewBookings(GetUserID());
                break;
            case 5: {
                int eventID;
                cout << "Enter event ID to modify booking: ";
                cin >> eventID;
                vector<int> newSeats;
                int newSeatCount;
                cout << "Enter number of new seats to book: ";
                cin >> newSeatCount;
                assert(newSeatCount > 0); // Ensure a positive number of new seats
                for (int i = 0; i < newSeatCount; ++i) {
                    int seatNumber;
                    cout << "Enter new seat number: ";
                    cin >> seatNumber;
                    newSeats.push_back(seatNumber);
                }
                Booking booking(GetUserID(), eventID, newSeats);
                booking.ModifyBooking(newSeats);
                break;
            }
            case 6: {
                int eventID;
                cout << "Enter event ID to cancel booking: ";
                cin >> eventID;
                Booking booking(GetUserID(), eventID, {});
                booking.CancelBooking();
                break;
            }
            case 0:
                return;
            default:
                cout << "Invalid choice.\n";
        }
    }
}

// Function to create a new user
User User::CreateUser(int id) {
    string username, password;
    cout << "Enter username: ";
    cin >> username;
    assert(!username.empty()); // Ensure username is not empty
    cout << "Enter password: ";
    cin >> password;
    assert(!password.empty()); // Ensure password is not empty
    return User(username, password, id);
}

int main() {
    vector<Person*> People;

    // Sample admin (for testing purposes)
    People.push_back(new Admin("admin", "admin123"));

    int mainChoice;

    while (true) {
        cout << "\n--- Main Menu ---\n";
        cout << "1. Admin Login\n";
        cout << "2. User Login\n";
        cout << "3. Create User Account\n"; // Available only here
        cout << "0. Exit\n";
        cout << "Select an option: ";
        cin >> mainChoice;

        switch (mainChoice) {
            case 1: {
                bool loggedIn = false;
                for (Person* person : People) {
                    if (dynamic_cast<Admin*>(person) && person->Login()) {
                        loggedIn = true;
                        dynamic_cast<Admin*>(person)->AdminMenu();
                        break;
                    }
                }
                if (!loggedIn) cout << "Invalid login.\n";
                break;
            }
            case 2: {
                bool loggedIn = false;
                for (Person* person : People) {
                    if (dynamic_cast<User*>(person) && person->Login()) {
                        loggedIn = true;
                        dynamic_cast<User*>(person)->UserMenu();
                        break;
                    }
                }
                if (!loggedIn) cout << "Invalid login.\n";
                break;
            }
            case 3: { // Create User Account
                static int nextUserID = 1; // Static variable for user ID
                User newUser = User::CreateUser(nextUserID++);
                People.push_back(new User(newUser.GetUsername(), newUser.GetPassword(), newUser.GetUserID()));
                cout << "Account created successfully.\n";
                break;
            }
            case 0:
                cout << "Exiting the system. Goodbye!\n";
                return 0;
            default:
                cout << "Invalid choice.\n";
        }
    }
}
